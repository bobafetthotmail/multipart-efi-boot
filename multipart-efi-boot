#!/bin/sh

# Author:
#
#     Alberto Bursi <alberto.bursi@outlook.it>
#
# Copyright:
#
#     Alberto Bursi 2025
#
# License:
#
#     This program is free software: you can redistribute it and/or modify
#     it under the terms of the GNU General Public License as published by
#     the Free Software Foundation, either version 3 of the License, or
#     (at your option) any later version.
#
#     This package is distributed in the hope that it will be useful,
#     but WITHOUT ANY WARRANTY; without even the implied warranty of
#     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#     GNU General Public License for more details.
#
#     You should have received a copy of the GNU General Public License
#     along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# On Debian systems, the complete text of the GNU General
# Public License version 3 can be found in `/usr/share/common-licenses/GPL-3'.


# I developed multipart-efi-boot to setup and manage the existence of multiple EFI boot partitions without the need for mdadm raid or complex GRUB setups on Debian or derivative distribution.
# This scripts implements it for EFI systems using systemd-boot, but the same idea can be applied to rEFInd or other EFI bootloaders as well.
# Also to be fully transparent, script is mimicking a functionality Proxmox also has, but it is not related to their proxmox-boot-tool script, it is written from scratch.
#
# This script is devloped for Debian only so I cannot guarantee it will work the same on your distribution.
# It is mostly reliant on debian-specific "installkernel" infrastructure aka the /etc/kernel/postinst.d
# and /etc/kernel/postrm.d folders of script hooks, but some distros like Gentoo seem to use them too.
# Feel free to send PRs with commits or open issues with instructions to add support for other distros


script_version=1.0

efipart_file="/etc/kernel/efiparts"

write_postinst(){
cat << 'EOF' > /etc/kernel/postinst.d/za-systemd-boot-multipartition
#!/bin/sh
#this script must be run before the zz-systemd-boot
test -x /usr/bin/bootctl || exit 1
echo "Installing kernel version $1 in systemd-boot..."

machine_id="$(cat /etc/machine-id)"

for i in $(cat /etc/kernel/efiparts | tr '\n' ' ' ); do
	umount /efi -q
	blkid | grep "$i" -q
	if [ "$?" = 0 ] ; then
		echo mounting "$i"
		mount "$(blkid | grep "$i" | awk -F':' '{print $1}')" -o fmask=0077,dmask=0077 /efi
		bootctl update --path=/efi
		echo "$1"
		kernel-install add "$1" "/boot/vmlinuz-$1" "/boot/initrd.img-$1"
		#creating the new config file for the special entry about booting a snapshot
		#this requires some shenanigans to because it contains special characters that are otherwise interpreted by the shell
		if [ -f  /etc/kernel/snapshots-cmdline ] ; then
            cp /efi/loader/entries/"$machine_id"-"$1".conf /efi/loader/entries/"$machine_id"-"$1"-snapshots.conf
            # add snapshots at the end of the name
            sed -i '/title/s/$/ snapshots/' /efi/loader/entries/"$machine_id"-"$1"-snapshots.conf
            # remove the line with kernel commandline
            sed -i '/options/d' /efi/loader/entries/"$machine_id"-"$1"-snapshots.conf
            # copy the line with kernel commandline
            echo "options $(cat /etc/kernel/snapshots-cmdline) systemd.machine_id=$machine_id" >> /efi/loader/entries/"$machine_id"-"$1"-snapshots.conf
        fi
	else
		echo EFI partition "$i" not found
	fi
done
#we do not unmount the last efi partition so the zz-systemd-boot script can run without issues
#umount /efi -q
exit 0
EOF

cat << 'EOF' > /etc/kernel/postinst.d/zz-systemd-boot-multipartition-post
#!/bin/sh
#this script must be run after the zz-systemd-boot
umount /efi -q
exit 0
EOF

chmod +x /etc/kernel/postinst.d/za-systemd-boot-multipartition
chmod +x /etc/kernel/postinst.d/zz-systemd-boot-multipartition-post

}

write_postrm(){
cat << 'EOF' > /etc/kernel/postrm.d/za-systemd-boot-multipartition
#!/bin/sh
#this script must be run before the zz-systemd-boot
test -x /usr/bin/bootctl || exit 1
echo "Removing kernel version $1 from systemd-bootâ€¦"

machine_id="$(cat /etc/machine-id)"

for i in $(cat /etc/kernel/efiparts | tr '\n' ' ' ); do
	umount /efi -q
	blkid | grep "$i" -q
	if [ "$?" = 0 ] ; then
		echo mounting "$i"
		mount "$(blkid | grep "$i" | awk -F':' '{print $1}')"  -o fmask=0077,dmask=0077 /efi
		kernel-install remove "$1"
		if [ -f  /etc/kernel/snapshots-cmdline ] ; then
            rm /boot/efi/loader/entries/"$machine_id"-"$1"-snapshots.conf -f
		fi
	else
		echo EFI partition "$i" not found
	fi
done
#we do not unmount the last efi partition so the zz-systemd-boot script can run without issues
#umount /efi -q
exit 0

EOF

cat << 'EOF' > /etc/kernel/postrm.d/zz-systemd-boot-multipartition-post
#!/bin/sh
#this script must be run after the zz-systemd-boot
umount /efi -q
exit 0
EOF

chmod +x /etc/kernel/postrm.d/za-systemd-boot-multipartition
chmod +x /etc/kernel/postrm.d/zz-systemd-boot-multipartition-post

}


cleanup_postinst_postrm(){

rm -f /etc/kernel/postrm.d/zz-systemd-boot-multipartition-post
rm -f /etc/kernel/postrm.d/za-systemd-boot-multipartition
rm -f /etc/kernel/postinst.d/zz-systemd-boot-multipartition-post
rm -f /etc/kernel/postinst.d/za-systemd-boot-multipartition

}



sync_kernel_initrd(){
version_list=$(find /boot -maxdepth 1 | grep initrd | cut -d/ -f3- | sed 's/initrd.img-//g' | tr '\n' ' ')

for version in $version_list ; do
    /etc/kernel/postinst.d/za-systemd-boot-multipartition "$version"
done

umount /efi -q

}


################MAIN##################


#doing a root check, because it must be run as root for obvious reasons
if [ "$(id -u)" -eq 0 ]; then
  echo
else
  echo "you must run the script as root"
  exit
fi

#checking that crucial tools are installed

for tool in cp mount umount rm chmod sed tr sfdisk efibootmgr mkfs.fat grep bootctl wipefs kernel-install; do

  tool_test=$( $tool --help > /dev/null 2>&1  ; echo $? )
  if [ "$tool_test" -ne 0 ]; then
    echo ERROR: $tool tool not found, please install it. Quitting
    exit 1
  fi

done

#awk is different so it gets its own checker
  tool_test=$( awk -W version > /dev/null 2>&1  ; echo $? )
  if [ "$tool_test" -ne 0 ]; then
    echo ERROR: awk tool not found, please install it. Quitting
    exit 1
  fi

umount /efi -q

#cleaning up device name by removing the /dev/ before it, since it is annoying to remember this
#only accepts the partition and not the full partition device name
cleaned_up_device_name="$( echo "$2" | sed 's|/dev/||g' )"


case "$1" in

add)

uuid=$( blkid | grep "$cleaned_up_device_name" | awk -F'"' '{print $2}' )

touch "$efipart_file"

grep "$uuid" "$efipart_file" -q

result="$?"

if [ "$result" = 0 ] ; then
    echo this partition is already in the list
    exit 0
fi

echo WARNING will format partition "$cleaned_up_device_name" Y/N
read -r input

if [ "$input" = "Y" ] || [ "$input" = "y" ]; then

    mkfs.fat -F 32 /dev/"$cleaned_up_device_name"

    new_blkid=$( blkid | grep /dev/"$cleaned_up_device_name" | awk -F'"' '{print $2}' )

    echo "$new_blkid" >> "$efipart_file"

    echo "$cleaned_up_device_name" | grep "^sd*" -q

    if [ "$?" = 0 ] ; then
        #this is a sdxx type of partition
        device_name=$( echo "$cleaned_up_device_name" | grep -Eo '[[:alpha:]]+' )
        part_number=$( echo "$cleaned_up_device_name" | grep -Eo '[0-9]+'  )
        sfdisk --part-type /dev/"$device_name" "$part_number" C12A7328-F81F-11D2-BA4B-00A0C93EC93B
    fi

    echo "$cleaned_up_device_name" | grep "^nvme*" -q

    if [ "$?" = 0 ] ; then
        #this is a nvmexx type of partition
        device_name="$( echo "$cleaned_up_device_name" | awk -F'p' '{ print $1 }' )"p
        part_number=$( echo "$cleaned_up_device_name" | awk -F'p' '{ print $2 }' )
        sfdisk --part-type /dev/"$device_name" "$part_number" C12A7328-F81F-11D2-BA4B-00A0C93EC93B
    fi

    mount /dev/"$cleaned_up_device_name" /efi

    bootctl install --path=/efi

    echo  "timeout 3" > /efi/loader/loader.conf
    echo  "editor 1" > /efi/loader/loader.conf

    sync_kernel_initrd

else

    echo task cancelled

fi
;;
remove)
    remove_blkid=$( blkid | grep /dev/"$cleaned_up_device_name" | awk -F'"' '{print $2}' )

    echo WARNING will format partition "$cleaned_up_device_name" Y/N
    read -r input

    if [ "$input" = "Y" ] || [ "$input" = "y" ]; then
        sed "s/$remove_blkid//g" -i "$efipart_file"
        wipefs -a /dev/"$cleaned_up_device_name"
    else
        echo task cancelled
    fi
;;

refresh)
    sync_kernel_initrd
;;

install-scripts)
    touch "$efipart_file"
    write_postinst
    write_postrm
    if [ -f "/etc/kernel/postrm.d/zz-systemd-boot-multipartition-post" ] && [ -f "/etc/kernel/postrm.d/za-systemd-boot-multipartition" ] && [  -f "/etc/kernel/postinst.d/zz-systemd-boot-multipartition-post" ] && [  -f "/etc/kernel/postinst.d/za-systemd-boot-multipartition" ]; then
        echo hook scripts installed
    else
        echo ERROR hook scripts not installed
    fi

;;

remove-scripts)
    rm "$efipart_file"
    cleanup_postinst_postrm
    if [ ! -f "/etc/kernel/postrm.d/zz-systemd-boot-multipartition-post" ] && [ ! -f "/etc/kernel/postrm.d/za-systemd-boot-multipartition" ] && [ ! -f "/etc/kernel/postinst.d/zz-systemd-boot-multipartition-post" ] && [ ! -f "/etc/kernel/postinst.d/za-systemd-boot-multipartition" ]; then
        echo hook scripts removed
    else
        echo ERROR hook scripts not removed
    fi
;;

version)

    echo
    echo the version is $script_version
    echo

;;

*)

echo 'multipart-efi-boot [ add | remove | refresh | install-scripts | remove-scripts | version ] [ /dev/sdxx | /dev/nvmexnxpx ] '

;;

esac


if [ ! -f "/etc/kernel/postrm.d/zz-systemd-boot-multipartition-post" ] || [ ! -f "/etc/kernel/postrm.d/za-systemd-boot-multipartition" ] || [ ! -f "/etc/kernel/postinst.d/zz-systemd-boot-multipartition-post" ] || [ ! -f "/etc/kernel/postinst.d/za-systemd-boot-multipartition" ]; then

echo WARNING: hook scripts not found in /etc/kernel/postrm.d and /etc/kernel/postinst.d
echo you must install them with
echo update-efipartlist install
echo

fi


sed -i '/^$/d' $efipart_file

echo current UUID of the EFI partitions in the list are
cat $efipart_file
